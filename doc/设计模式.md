# 创建型模式 - Creational

创建型模式抽象了实例化的过程

### 抽象工厂模式(AbstractFactory Pattern)

- 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要明确指定具体类

#### 示例
xx

### 建造者模式(Builder Pattern)

- 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示

#### 示例
xx

### 工厂模式(Factory Pattern)

- 定义一个创建对象的接口,让子类决定实例化哪一个类

#### 示例
xx

### 原型模式(Prototype Pattern)

用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象

#### 示例
xx

### 单例模式 - Singleton Pattern

- 保证一个类仅有一个实例, 并提供一个访问它的全局访问点

#### 示例

1. 写一个单例类
```java
public static final class Singleton {

    private volatile static Singleton INSTANCE;

    /**
     * 将构造方法私有化
     */
    private Singleton() {}

    /**
     * 提供一个静态方法获取实例对象
     */
    private static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }

    public void display(){
        System.out.println("display");
    }
}
```
2. 组织代码测试
```java
public class SingletonPattern {
    public static void main(String[] args) {
        Singleton.getInstance().display();
    }
}
```
4. 输出结果
```
display
```



# 结构型模式


# 行为型模式

## 策略模式 - Strategy Pattern

- 定义了算法族, 分别封装起来, 让它们之间可以相互替换, 此模式让算法的变化独立于使用算法的客户

#### 示例

- 一个鸭子有三个行为：fly, quack, display
- 但是不同的鸭子的行为不同, 有的鸭子可以飞, 有的鸭子不会飞等
- 需要可以在运行中, 替换鸭子的行为能力

1. 定义飞的行为

```java
  /**
 * 鸭子飞的行为
 */
public interface FlyBehavior {
    void fly();
}
```

2. 定义叫的行为

```java
  /**
 * 鸭子叫的行为
 */
public interface QuackBehavior {
    void quack();
}
```

3. 定义一个抽象类鸭子

```java
  /**
 * 鸭子类型
 */
public static abstract class Duck {
    FlyBehavior mFlyBehavior;
    QuackBehavior mQuackBehavior;

    /**
     * 替换飞的行为
     */
    public void setFlyBehavior(FlyBehavior flyBehavior) {
        this.mFlyBehavior = flyBehavior;
    }

    /**
     * 替换呱呱叫的行为
     */
    public void setQuackBehavior(QuackBehavior quackBehavior) {
        this.mQuackBehavior = quackBehavior;
    }

    /**
     * 执行飞的行为
     */
    public void preformFly() {
        mFlyBehavior.fly();
    }

    /**
     * 执行呱呱叫的行为
     */
    public void preformQuack() {
        mQuackBehavior.quack();
    }

    /**
     * 显示外观
     */
    public abstract void display();
}
```

4. 提供飞行为

```java
  public static class FlyWithWings implements FlyBehavior {
    @Override
    public void fly() {
        System.out.println("fly with wings");
    }
}

public static class FlyNotWay implements FlyBehavior {
    @Override
    public void fly() {
        System.out.println("can't fly");
    }
} 
```

5. 提供鸭子叫的行为

```java
  public static class Quack implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println("quack");
    }
}

public static class Squeak implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println("squeak");
    }
}
```

6. 定义一个鸭子

```java
  public static class StupidDuck extends Duck {

    public StupidDuck() {
        // 初始化飞的行为
        mFlyBehavior = new FlyNotWay();

        // 初始化呱呱叫的行为
        mQuackBehavior = new Quack();
    }

    @Override
    public void display() {
        System.out.println("red head display");
    }
}
```

7组织代码测试

```java
  public class StrategyPattern {
    public static void main(String[] args) {
        Duck stupidDuck = new StupidDuck();

        // 一开始不会飞
        stupidDuck.preformFly();

        // 替换了飞的行为（算法）之后, 会飞了
        stupidDuck.setFlyBehavior(new FlyWithWings());
        stupidDuck.preformFly();

        stupidDuck.preformQuack();
        stupidDuck.display();
    }
}
```

8. 输入

```
can't fly
fly with wings
quack
red head display 
```

#### 个人理解

- 抽象类定义了一个空壳子, 具体的执行依赖使用的策略(算法族)



## 观察者模式 - Observer Pattern

- 定义了对象之间的一对多依赖, 这样以来当一个对象改变状态时, 它的依赖者都会收到通知并更新

#### 示例

- 当状态改变时, 多个页面需要同时更新显示内容

1. 定义一个可被观察的主题

```java
/**
 * 定义一个主题
 * 主题包含了状态：mValue
 * 当状态改变时，通知所有观察者
 */
public static class Subject {

    private final List<Observer> mObserverList = new ArrayList<>();
    private int mValue;

    /**
     * 注册观者者
     */
    public void registerObserver(Observer observer) {
        mObserverList.add(observer);
    }

    /**
     * 解注册观者者
     */
    public void unregisterObserver(Observer observer) {
        mObserverList.remove(observer);
    }

    /**
     * 更新状态
     */
    public void setValue(int value) {
        this.mValue = value;

        // 通知所有观察者状态更新
        notifyObservers();
    }

    /**
     * 通知所有观者者状态更新
     */
    public void notifyObservers() {
        for (Observer observer : mObserverList) {
            observer.update(mValue);
        }
    }
}
```

2. 定义一个观察者

```java
 /**
 * 定义一个接收状态改变的观察者接口
 */
public interface Observer {
    void update(int value);
} 
```

3. 组织代码测试

```java
public class ObserverPattern {
    public static void main(String[] args) {
        Subject subject = new Subject();

        // 注册两个观者者
        subject.registerObserver(value -> System.out.println("observer 1 received: " + value));
        subject.registerObserver(value -> System.out.println("observer 2 received: " + value));

        // 更改状态
        subject.setValue(1);
    }
}
```
4. 输出结果
```
observer 1 received: 1
observer 2 received: 1
```

#### 个人理解
- 把所有想接收状态改变的对象装到一个列表里, 当状态改变时, 就遍历列表中所有的对象并通知