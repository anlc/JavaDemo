# 创建型模式 - Creational

创建型模式抽象了实例化的过程

### 抽象工厂模式(AbstractFactory Pattern)

- 意图

- 定义 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要明确指定具体类

- 应用场景

### 建造者模式(Builder Pattern)

- 意图 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示
- 定义

- 应用场景

### 工厂模式(Factory Pattern)

- 意图 定义一个创建对象的接口,让子类决定实例化哪一个类

- 定义

- 应用场景

### 原型模式(Prototype Pattern)

- 意图 用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象

- 定义

- 应用场景

### 单例模式 - Singleton Pattern

- 意图 保证一个类仅有一个实例, 并提供一个访问它的全局访问点

- 场景

- 应用场景

```java
public class DoubleCheckSingletonPattern {

    static class Singleton {

        private volatile static Singleton INSTANCE;

        private static Singleton getInstance() {
            if (INSTANCE == null) {
                synchronized (Singleton.class) {
                    if (INSTANCE == null) {
                        INSTANCE = new Singleton();
                    }
                }
            }
            return INSTANCE;
        }

        @Override
        public String toString() {
            return "double check singleton pattern";
        }
    }

    @Test
    public void testPattern() {
        System.out.println(Singleton.getInstance().toString());
    }
}
```

# 结构型模式

# 行为型模式

### 策略模式 - Strategy Pattern

**意图**

- 定义了算法族, 分别封装起来, 让它们之间可以相互替换, 此模式让算法的变化独立于使用算法的客户

**使用场景**

**示例**

- 一个鸭子有三个行为：fly, quack, display
- 但是不同的鸭子的行为不同, 有的鸭子可以飞, 有的鸭子不会飞等
- 需要可以在运行中, 替换鸭子的行为能力

1. 定义飞的行为
```java
  /**
   * 鸭子飞的行为
   */
  public interface FlyBehavior {
      void fly();
  }
```
2. 定义叫的行为
```java
  /**
   * 鸭子叫的行为
   */
  public interface QuackBehavior {
    void quack();
  }
```
3. 定义一个抽象类鸭子
```java
  /**
   * 鸭子类型
   */
  public static abstract class Duck {
    FlyBehavior mFlyBehavior;
    QuackBehavior mQuackBehavior;
  
    /**
     * 替换飞的行为
     * @param flyBehavior
     */
    public void setFlyBehavior(FlyBehavior flyBehavior) {
      this.mFlyBehavior = flyBehavior;
    }
  
    /**
     * 替换呱呱叫的行为
     * @param quackBehavior
     */
    public void setQuackBehavior(QuackBehavior quackBehavior) {
      this.mQuackBehavior = quackBehavior;
    }
  
    /**
     * 执行飞的行为
     */
    public void preformFly(){
      mFlyBehavior.fly();
    }
  
    /**
     * 执行呱呱叫的行为
     */
    public void preformQuack(){
      mQuackBehavior.quack();
    }
  
    /**
     * 显示外观
     */
    public abstract void display();
  }
```

4. 提供飞行为
```java
  public static class FlyWithWings implements FlyBehavior {
    @Override
    public void fly() {
      System.out.println("fly with wings");
    }
  }
  
  public static class FlyNotWay implements FlyBehavior {
    @Override
    public void fly() {
      System.out.println("can't fly");
    }
  } 
```

5. 提供鸭子叫的行为
```java
  public static class Quack implements QuackBehavior {
      @Override
      public void quack() {
          System.out.println("quack");
      }
  }
  
  public static class Squeak implements QuackBehavior {
      @Override
      public void quack() {
          System.out.println("squeak");
      }
  }
```

6. 定义一个鸭子
```java
  public static class StupidDuck extends Duck{

    public StupidDuck() {
      // 初始化飞的行为
      mFlyBehavior = new FlyNotWay();
  
      // 初始化呱呱叫的行为
      mQuackBehavior = new Quack();
    }
  
    @Override
    public void display() {
      System.out.println("red head display");
    }
  }
```

6. 组织代码测试
```java
  public class StrategyPattern {
    public static void main(String[] args) {
      Duck stupidDuck = new StupidDuck();
  
      // 一开始不会飞
      stupidDuck.preformFly();
  
      // 替换了飞的行为（算法）之后, 会飞了
      stupidDuck.setFlyBehavior(new FlyWithWings());
      stupidDuck.preformFly();
  
      stupidDuck.preformQuack();
      stupidDuck.display();
    }
  }
```
7. 输入
```
can't fly
fly with wings
quack
red head display 
```